<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Wunderblock</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style type="text/css">
			#overlay {
			position: absolute;
			font-size: 16px;
			z-index: 2;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			flex-direction: column;
			/*background: rgba(0,0,0,0.7); */
			background-image: url("texture/skin/Skin_01_basecolor.jpg");
		}

			#overlay button {
				background: transparent;
				border: 0;
				border: 1px solid rgb(255, 255, 255);
				border-radius: 4px;
				color: #ffffff;
				padding: 12px 18px;
				text-transform: uppercase;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<div  id="song">
		<!--<audio id="breath1" loop preload="auto" style="display: none">
			<source src="sound/breath1.ogg" type="audio/ogg">
			<source src="sound/breath1.mp3" type="audio/mpeg">
		</audio>
		<audio id="breath2" loop preload="auto" style="display: none">
			<source src="sound/breath2.ogg" type="audio/ogg">
			<source src="sound/breath2.mp3" type="audio/mpeg">
		</audio>
		<audio id="breath3" loop preload="auto" style="display: none">
			<source src="sound/breath3.ogg" type="audio/ogg">
			<source src="sound/breath3.mp3" type="audio/mpeg">
		</audio>
		<audio id="breath4" loop preload="auto" style="display: none">
			<source src="sound/breath4.ogg" type="audio/ogg">
			<source src="sound/breath4.mp3" type="audio/mpeg">
		</audio>-->
		</div>

		<div id="overlay">
			<button id="startButton">Enter the WUnderblock</button>
		</div>
		<div id="container"></div>
		
	<script src="https://cdn.rawgit.com/mrdoob/three.js/master/build/three.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	 <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/libs/stats.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	 <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	    <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/math/MeshSurfaceSampler.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	   <script src="./js/DecalGeometry.js"></script>
	    <script src="./js/socket.io.js"></script>

	    <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/postprocessing/Pass.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	    <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/postprocessing/ShaderPass.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	    <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/shaders/CopyShader.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	    <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/shaders/LuminosityHighPassShader.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


	    <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/postprocessing/EffectComposer.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	    <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/postprocessing/RenderPass.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	    <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/postprocessing/UnrealBloomPass.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	    
	    <script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D baseTexture;
			uniform sampler2D bloomTexture;

			varying vec2 vUv;

			void main() {

				gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

			}

		</script>
  	

		<script>

			const ENTIRE_SCENE = 0, BLOOM_SCENE = 1;

			let bloomComposer, finalComposer;

			const bloomLayer = new THREE.Layers();
			bloomLayer.set( BLOOM_SCENE );

			const paramsBloom = {
				exposure: 1,
				bloomStrength: 1, //3
				bloomThreshold: 0,
				bloomRadius: 0.2,
				scene: "Scene with Glow"
			};

			const darkMaterial = new THREE.MeshBasicMaterial( { color: "black" } );
			const materials = {};



			var socket = io.connect( "http://localhost:3000"); //io();//.connect("127.0.0.1", {port: 3000});

			socket.on("foo", function(message) { 
           			console.log("foo: ", message);
           			genTrace(genPosition(), message); 
           	});


			let traceData2;

			/* 

				Before page finish load, get all audio file and preload them
				+ add audio file in cache buffer would be better

			*/

			function getData(){
				console.log("getdata")
				// if audio not in cache
				fetch("/traces").then(req => req.text()).then(loadAudio);
			}


			function loadAudio(data){
				this.traceData = JSON.parse(data); // + mettre en cache
				traceData2 = this.traceData;

				console.log("loadAudio ", this.traceData, traceData2);
				jQuery.each(this.traceData, function(i, val) {
					createAudio(val.id);
				});

			}


			function createAudio(id){

				console.log("createAudio ", id)

				// check file exist ? eviter ...

				$.get('sound/breath'+id+'.mp3')
				    .done(function() { 

				    	console.log("oui ", id)

				    	// exists
				        var sound      = document.createElement('audio');
						sound.id       = 'breath'+id;
						sound.preload = 'auto';
						sound.loop = true;
						sound.src      = 'sound/breath'+id+'.mp3';
						sound.type     = 'audio/mpeg';
						sound.style.display = "none";
						document.getElementById('song').appendChild(sound);

						return true;

				    }).fail(function() { 
				        // not exists code
				        console.log("404 ", id)
				        return false;
				    })

			}

			getData();


			const container = document.getElementById( 'container' );

			let renderer, scene, camera, stats;
			let mesh, sampler;
			let raycaster;
			let line;

			const intersection = {
				intersects: false,
				point: new THREE.Vector3(),
				normal: new THREE.Vector3()
			};
			const mouse = new THREE.Vector2();
			const intersects = [];

			const textureLoader = new THREE.TextureLoader();
			const audioLoader = new THREE.AudioLoader();
			const listener = new THREE.AudioListener();


			// à voir perf si garder clone + changement texture
			/*
			const decalMaterial = new THREE.MeshPhongMaterial( {
						//specular: 0x111111,
						//color : 0xffff00,
						map: textureLoader.load( 'texture/cv/skinmask.png' ),// textureLoader.load( 'texture/cv/blur.png' ),//textureLoader.load( 'texture/spec100.png' ),// textureLoader.load( 'texture/SpecularMapr.png' ),//mytexture,//mytexture,//decalDiffuse
						//bumpMap :  textureLoader.load( 'texture/img32b.png' ),// mytexture,
						//map:  textureLoader.load( 'texture/spec.png' ),//mytexture,//mytexture,//decalDiffuse
						bumpMap :    textureLoader.load( 'texture/cv/blurotsu100trans.png' ),//textureLoader.load( 'texture/bump.png' ),
						bumpScale : 15,
						opacity: 0.6,
						depthWrite: false,
    					alphaTest: 0.05,
						//normalMap: normaldecal,//decalNormal,
						shininess: 25,
						transparent: true,
						depthTest: true,
						//depthWrite: false,
						shading: THREE.SmoothShading,
						side: THREE.DoubleSide, 
						polygonOffset: true,
						polygonOffsetFactor: - 4,
						wireframe: false
					} );
				*/


			const decals = [];
			let mouseHelper;
			const position = new THREE.Vector3();
			const orientation = new THREE.Euler();
			const size = new THREE.Vector3( 10, 10, 10 );

			const params = {
				minScale: 30,//10
				maxScale: 80,
				rotate: true,
				clear: function () {

					removeDecals();

				}
			};

			//window.addEventListener( 'load', init );
			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', init );

			function init() {

				console.log("init ", this.traceData);

				const overlay = document.getElementById( 'overlay' );
				overlay.remove();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				//renderer.toneMapping = THREE.ReinhardToneMapping; //

				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				scene = new THREE.Scene();
				//scene.background = new THREE.Color( 0x0000ff );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 120;


				camera.add( listener );

				// Limit zoom camera
				const controls = new THREE.OrbitControls( camera, renderer.domElement );
				//controls.minDistance = 50;
				//controls.maxDistance = 200;

				scene.add( new THREE.AmbientLight( 0x443333 ) );

				const dirLight1 = new THREE.DirectionalLight( 0xffddcc, 1 );
				dirLight1.position.set( 1, 0.75, 0.5 );
				scene.add( dirLight1 );

				const dirLight2 = new THREE.DirectionalLight( 0xccccff, 1 );
				dirLight2.position.set( - 1, 0.75, - 0.5 );
				scene.add( dirLight2 );

				const geometry = new THREE.BufferGeometry();
				geometry.setFromPoints( [ new THREE.Vector3(), new THREE.Vector3() ] );

				line = new THREE.Line( geometry, new THREE.LineBasicMaterial() );
				scene.add( line );

				mouseHelper = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 10 ), new THREE.MeshNormalMaterial() );
				mouseHelper.visible = false;
				scene.add( mouseHelper );


				/* Aura effect */

				const renderScene = new THREE.RenderPass( scene, camera );

				const bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
				bloomPass.threshold = paramsBloom.bloomThreshold;
				bloomPass.strength = paramsBloom.bloomStrength;
				bloomPass.radius = paramsBloom.bloomRadius;

				bloomComposer = new THREE.EffectComposer( renderer );
				bloomComposer.renderToScreen = false;
				bloomComposer.addPass( renderScene );
				bloomComposer.addPass( bloomPass );

				const finalPass = new THREE.ShaderPass(
					new THREE.ShaderMaterial( {
						uniforms: {
							baseTexture: { value: null },
							bloomTexture: { value: bloomComposer.renderTarget2.texture }
						},
						vertexShader: document.getElementById( 'vertexshader' ).textContent,
						fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
						defines: {}
					} ), "baseTexture"
				);
				finalPass.needsSwap = true; 

				finalComposer = new THREE.EffectComposer( renderer );
				finalComposer.addPass( renderScene );
				finalComposer.addPass( finalPass );

		    




				buildTerrain();
				// get all existing traces
				//fetch("http://xoqhbtq.cluster030.hosting.ovh.net/traces").then(req => req.text()).then(createTraces);
				//fetch("/traces").then(req => req.text()).then(createTraces);
				/*
				console.log(this.traceData);
				if(this.traceData){
					console.log("deja load")
					createTraces(this.traceData);
				}
				else{ // pas ok car audio pas créé
					console.log("pas")
					fetch("/traces").then(req => req.text()).then(createTraces);
				}
				*/

				createTraces();
				
				//toyTraces();
/*

				window.addEventListener( 'resize', onWindowResize );

				let moved = false;

				controls.addEventListener( 'change', function () {

					moved = true;

				} );

				window.addEventListener( 'pointerdown', function () {

					moved = false;

				} ); */


		
				onWindowResize();
				animate();
				//render();

			}

			/* Création du terrain */

			function buildTerrain() {

				var nSkin = '1'; // voir 1 et 8
				var skinPath = 'texture/skin/Skin_0'+nSkin+'_';


				const geometry = new THREE.PlaneGeometry( 500, 500 );
				const material = new THREE.MeshPhongMaterial( {
						specular: 0x111111,
						aoMap: textureLoader.load( skinPath+'ambientocclusion.jpg'),
						metalnessMap : textureLoader.load( skinPath+'metallic.jpg'),
						roughnessMap : textureLoader.load( skinPath+'roughness.jpg'),
						map: textureLoader.load( skinPath+'basecolor.jpg'),//( 'texture/Map-COL.jpg' ),
						//specularMap: textureLoader.load( 'texture/Map-SPEC.jpg' ), ??
						normalMap: textureLoader.load( skinPath+'normal.jpg'),//textureLoader.load( 'texture/Infinite-Level_02_Tangent_SmoothUV.jpg' ), 
						shading: THREE.SmoothShading, // ?
						shininess: 25
					} ); 
				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				// sampler ne sera plus utilisé ici, seulement dans la génération POST
					sampler = new THREE.MeshSurfaceSampler( mesh )
						.setWeightAttribute( 'color' )
						.build();

				

			}


			function createTraces(){

				//console.log("create traces", data, this.traceData, traceData2);

				if(this.traceData){

					console.log("ok"); 

					
					// ici ajouter args blob image et son
					jQuery.each(this.traceData, function(i, val) {
						
						genTrace(genPosition(), val);
						//genTrace(val);
					});

				}
				else{
					console.log("pas ok")
				}

			}


			function genPosition(){

				const _position = new THREE.Vector3();
				sampler.sample( _position );
				return _position;
			}




			function toyTraces(){

				console.log("100 random traces");

				// sampler ne sera plus utilisé ici, seulement dans la génération POST
				sampler = new THREE.MeshSurfaceSampler( mesh )
					.setWeightAttribute( 'color' )
					.build();

				const _position = new THREE.Vector3();

				// Sample randomly from the surface, creating an instance of the sample
				// geometry at each sample point.
				for ( let i = 0; i < 3; i ++ ) {

					sampler.sample( _position );
					genTrace(_position, i);

				}

			}

			function getRandomInt(min, max) {
			    min = Math.ceil(min);
			    max = Math.floor(max);
			    return Math.floor(Math.random() * (max - min + 1)) + min;
			}

			// Trace constructor + Gen Trace data po

			function genTrace(position, data) {

				console.log("genTrace ", data)


				orientation.copy( mouseHelper.rotation );

				if ( params.rotate ) orientation.z = Math.random() * 2 * Math.PI;

				// Size of trace : 
				const scale = params.minScale + Math.random() * ( params.maxScale - params.minScale );
				size.set( scale, scale, scale );

				const material =  new THREE.MeshPhongMaterial( {
	
						map: textureLoader.load( 'texture/cv/'+data.map+'.png' ),
						bumpMap :    textureLoader.load( 'texture/cv/'+data.bump+'.png' ),
						bumpScale : 30,
						opacity: 0.6,
						depthWrite: false,
    					alphaTest: 0.05,
						shininess: 25,
						transparent: true,
						depthTest: true,
						side: THREE.DoubleSide, 
						polygonOffset: true,
						polygonOffsetFactor: - 4,
						wireframe: false
					} );
			
				const m = new THREE.Mesh( new THREE.DecalGeometry( mesh, position, orientation, size ), material );



				var nSound = getRandomInt(1,3);
				var sound = new THREE.PositionalAudio( listener );
				const audioElem = document.getElementById( 'breath'+(data.id) );

				console.log("audioElem", audioElem)
				// ssi audio exist
				if(audioElem){
					sound.setMediaElementSource( audioElem );
					sound.setRefDistance( 20 );
					sound.setVolume( 10 );
					audioElem.play();
					m.add( sound );

				}

				decals.push( m );
				scene.add( m );

				if ( Math.random() < 0.25 ) m.layers.enable( BLOOM_SCENE );
				//m.layers.enable( BLOOM_SCENE );


			}
			
			function genTrace2(position, index) {

				console.log("index ", index+1);


				orientation.copy( mouseHelper.rotation );

				if ( params.rotate ) orientation.z = Math.random() * 2 * Math.PI;

				// Size of trace : 
				const scale = params.minScale + Math.random() * ( params.maxScale - params.minScale );
				size.set( scale, scale, scale );

				const material =  new THREE.MeshPhongMaterial( {
	
						map: textureLoader.load( 'texture/cv/skinmask.png' ),
						bumpMap :    textureLoader.load( 'texture/cv/blurotsu100trans.png' ),
						bumpScale : 30,
						opacity: 0.6,
						depthWrite: false,
    					alphaTest: 0.05,
						shininess: 25,
						transparent: true,
						depthTest: true,
						side: THREE.DoubleSide, 
						polygonOffset: true,
						polygonOffsetFactor: - 4,
						wireframe: false
					} );
			
				const m = new THREE.Mesh( new THREE.DecalGeometry( mesh, position, orientation, size ), material );



				var nSound = getRandomInt(1,3);
				var sound = new THREE.PositionalAudio( listener );
				const audioElem = document.getElementById( 'breath'+(index+1) );
				sound.setMediaElementSource( audioElem );
				sound.setRefDistance( 20 );
				sound.setVolume( 10 );
				audioElem.play();
				m.add( sound );
				decals.push( m );
				scene.add( m );


			}

			function removeDecals() {

				decals.forEach( function ( d ) {

					scene.remove( d );

				} );

				decals.length = 0;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				//renderer.render( scene, camera );
				render();

				stats.update();

			}

			function render(){
				// render scene with bloom
				renderBloom( true );

						// render the entire scene, then render bloom scene on top
				finalComposer.render();
			}

			function renderBloom( mask ) {

				if ( mask === true ) {

					scene.traverse( darkenNonBloomed );
					bloomComposer.render();
					scene.traverse( restoreMaterial );

				} else {

					camera.layers.set( BLOOM_SCENE );
					bloomComposer.render();
					camera.layers.set( ENTIRE_SCENE );

				}

			}

			function darkenNonBloomed( obj ) {

				if ( obj.isMesh && bloomLayer.test( obj.layers ) === false ) {

					materials[ obj.uuid ] = obj.material;
					obj.material = darkMaterial;

				}

			}

			function restoreMaterial( obj ) {

				if ( materials[ obj.uuid ] ) {

					obj.material = materials[ obj.uuid ];
					delete materials[ obj.uuid ];

				}

			}

			window.onresize = function () {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

				bloomComposer.setSize( width, height );
				finalComposer.setSize( width, height );

				render();

			};


		</script>

	</body>
</html>
