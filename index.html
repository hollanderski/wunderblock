<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Wunderblock</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style type="text/css">
			#overlay {
			position: absolute;
			font-size: 16px;
			z-index: 2;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			flex-direction: column;
			/*background: rgba(0,0,0,0.7); */
			background-image: url("texture/skin/Skin_01_basecolorpink4.jpg");
		}

			#overlay button {
				background: transparent;
				border: 0;
				border: 1px solid rgb(255, 255, 255);
				border-radius: 4px;
				color: #ffffff;
				padding: 12px 18px;
				text-transform: uppercase;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<div  id="song">
		</div>

		<div id="overlay">
			<button id="startButton">Enter the Wunderblock</button>
		</div>
		<div id="container"></div>
		
	<script src="./js/socket.io.js"></script>
	<script src="./js/three.min.js"></script>
	<script src="./js/jquery.min.js"></script>
	<script src="./js/stats.min.js"></script>
	<script src="./js/OrbitControls.js"></script>
	<script src="./js/MeshSurfaceSampler.js"></script>
	<script src="./js/Pass.js"></script>
	<script src="./js/ShaderPass.js"></script>
	<script src="./js/CopyShader.js"></script>
	<script src="./js/LuminosityHighPassShader.js"></script>
	<script src="./js/EffectComposer.js"></script>
	<script src="./js/RenderPass.js"></script>
	<script src="./js/UnrealBloomPass.js"></script>
	<script src="./js/DecalGeometry.js"></script>
	<script src="./js/perlin2.js"></script>


	    <script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D baseTexture;
			uniform sampler2D bloomTexture;

			varying vec2 vUv;

			void main() {

				gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

			}

		</script>

		<script>

			const today = new Date().toISOString().split('T')[0]
			var dir = 1;

			var clock = new THREE.Clock();
			var delta = 0;

			const ENTIRE_SCENE = 0, BLOOM_SCENE = 1;

			let bloomComposer, finalComposer;

			const bloomLayer = new THREE.Layers();
			bloomLayer.set( BLOOM_SCENE );

			const paramsBloom = {
				exposure: 1,
				bloomStrength: 3, //3
				bloomThreshold: 0,
				bloomRadius: 0.2,
				scene: "Scene with Glow"
			};

			const darkMaterial = new THREE.MeshBasicMaterial( { color: "black" } );
			const materials = {};



			
			var socket = io(); 

			socket.on("createTrace", function(message){

				createAudio(message.sound);
				genTrace(message); 
				

           	});




			let traceData2;


			/* Utils */


			function hmsToSeconds(s) {
			  var b = s.split(':');
			  return b[0]*3600 + b[1]*60 + (+b[2] || 0);
			}

			function ramp(x, in_min, in_max, out_min, out_max) {
			  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
			}
 


			/* 

				Before page finish load, get all audio file and preload them
				+ add audio file in cache buffer would be better

			*/

			function getData(){
				// if audio not in cache
				fetch("/traces").then(req => req.text()).then(loadAudio);
			}


			function loadAudio(data){
				this.traceData = JSON.parse(data); // + mettre en cache
				traceData2 = this.traceData;

				jQuery.each(this.traceData, function(i, val) {
					createAudio(val.sound);
				});

			}


			function createAudio(path){


				// check file exist ? eviter ...

				$.get('sound/'+path)
				    .done(function() { 


				    	// exists
				        var sound      = document.createElement('audio');
						sound.id       = path;
						sound.preload = 'auto';
						sound.loop = true;
						sound.src      = 'sound/'+path;
						sound.type     = 'audio/mpeg';
						sound.style.display = "none";
						document.getElementById('song').appendChild(sound);

						return true;

				    }).fail(function() { 
				        // not exists code
				        console.log("404 ", path)
				        return false;
				    })

			}

			getData();


			const container = document.getElementById( 'container' );

			let renderer, scene, camera, stats;
			let mesh, sampler;
			let raycaster;
			let line;

			const intersection = {
				intersects: false,
				point: new THREE.Vector3(),
				normal: new THREE.Vector3()
			};
			const mouse = new THREE.Vector2();
			const intersects = [];

			const textureLoader = new THREE.TextureLoader();
			const audioLoader = new THREE.AudioLoader();
			const listener = new THREE.AudioListener();
			const decals = [];
			let mouseHelper;
			const position = new THREE.Vector3();
			const orientation = new THREE.Euler();
			const size = new THREE.Vector3( 10, 10, 10 );

			const params = {
				minScale: 30,//10
				maxScale: 80,
				rotate: true,
				clear: function () {

					removeDecals();

				}
			};

			//window.addEventListener( 'load', init );
			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', init );

			function init() {


				const overlay = document.getElementById( 'overlay' );
				overlay.remove();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				scene = new THREE.Scene();
				//scene.background = new THREE.Color( 0x0000ff );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 ); // 1, 1000
				//camera.position.z = 1000; //120
				camera.add( listener );

				camera.position.x = 122;
				camera.position.y = 460;
				camera.position.z = 1430;

				// Limit zoom camera
				const controls = new THREE.OrbitControls( camera, renderer.domElement );
				
				//controls.minDistance = 1000;
				controls.maxDistance = 10000;
				controls.maxPolarAngle = Math.PI / 2;
				//controls.minDistance = 50;
				//controls.maxDistance = 200;

				scene.add( new THREE.AmbientLight( 0x443333 ) );
				const dirLight1 = new THREE.DirectionalLight( 0xffddcc, 1 );
				dirLight1.position.set( 1, 0.75, 0.5 );
				scene.add( dirLight1 );
	
				const dirLight2 = new THREE.DirectionalLight( 0xccccff, 1 );
				dirLight2.position.set( - 1, 0.75, - 0.5 );
				scene.add( dirLight2 );

				const geometry = new THREE.BufferGeometry();
				geometry.setFromPoints( [ new THREE.Vector3(), new THREE.Vector3() ] );

				line = new THREE.Line( geometry, new THREE.LineBasicMaterial() );
				scene.add( line );

				mouseHelper = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 10 ), new THREE.MeshNormalMaterial() );
				mouseHelper.visible = false;
				scene.add( mouseHelper );


	

				/* Aura effect */

				const renderScene = new THREE.RenderPass( scene, camera );

				const bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
				bloomPass.threshold = paramsBloom.bloomThreshold;
				bloomPass.strength = paramsBloom.bloomStrength;
				bloomPass.radius = paramsBloom.bloomRadius;

				bloomComposer = new THREE.EffectComposer( renderer );
				bloomComposer.renderToScreen = false;
				bloomComposer.addPass( renderScene );
				bloomComposer.addPass( bloomPass );

				const finalPass = new THREE.ShaderPass(
					new THREE.ShaderMaterial( {
						uniforms: {
							baseTexture: { value: null },
							bloomTexture: { value: bloomComposer.renderTarget2.texture }
						},
						vertexShader: document.getElementById( 'vertexshader' ).textContent,
						fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
						defines: {}
					} ), "baseTexture"
				);
				finalPass.needsSwap = true; 

				finalComposer = new THREE.EffectComposer( renderer );
				finalComposer.addPass( renderScene );
				finalComposer.addPass( finalPass );



				buildTerrain();
				createTraces();
				
				//toyTraces();

/*
				window.addEventListener( 'resize', onWindowResize ); */

				let moved = false;

				controls.addEventListener( 'change', function () {

					moved = true;

				} );

				window.addEventListener( 'pointerdown', function () {

					moved = false;

				} );


		
			//	onWindowResize();
				animate();

			}

			/* Création du terrain */

			function buildTerrain() {

				var nSkin = '1'; // voir 1 et 8
				var skinPath = 'texture/skin/Skin_0'+nSkin+'_';


				const geometry = new THREE.PlaneGeometry(  2000, 2000, 256, 256);
				const material = new THREE.MeshPhongMaterial( {
						specular: 0x111111,
						aoMap: textureLoader.load( skinPath+'ambientocclusion.jpg'),
						displacementMap : textureLoader.load( skinPath+'height.jpg'),
						//metalnessMap : textureLoader.load( skinPath+'metallic.jpg'),
						//roughnessMap : textureLoader.load( skinPath+'roughness.jpg'),
						map: textureLoader.load( skinPath+'basecolorpink4.jpg'),//( 'texture/Map-COL.jpg' ),
						//specularMap: textureLoader.load( 'texture/Map-SPEC.jpg' ), ??
						normalMap: textureLoader.load( skinPath+'normal.jpg'),//textureLoader.load( 'texture/Infinite-Level_02_Tangent_SmoothUV.jpg' ), 
						shininess: 25
					} ); 
				mesh = new THREE.Mesh( geometry, material );


				 

				//Perlin noise on terrain 

				var peak = 100;
				var smoothing = 150; //300

				var vertices = mesh.geometry.attributes.position.array;

    			for (var i = 0; i <= vertices.length; i += 3) {
						vertices[i+2] = peak * noise.perlin2(
		            (mesh.position.x + vertices[i])/smoothing, 
		            (mesh.position.z + vertices[i+1])/smoothing
		        );
		    }
				mesh.geometry.attributes.position.needsUpdate = true;
				mesh.geometry.computeVertexNormals();

				mesh.geometry.rotateX( - Math.PI / 2 );


				scene.add( mesh );

				// sampler ne sera plus utilisé ici, seulement dans la génération POST
					sampler = new THREE.MeshSurfaceSampler( mesh )
						.setWeightAttribute( 'color' )
						.build();

				

			}


			function createTraces(){

				if(this.traceData){
					
					// ici ajouter args blob image et son
					jQuery.each(this.traceData, function(i, val) {
						
						genTrace(val);
						//genTrace(val);
					});

				}
				else{
					console.log("ERROR")
				}

			}


			function genPosition(){

				const _position = new THREE.Vector3();
				sampler.sample( _position );
				return _position;
			}



			function toyTraces(){


				// sampler ne sera plus utilisé ici, seulement dans la génération POST
				sampler = new THREE.MeshSurfaceSampler( mesh )
					.setWeightAttribute( 'color' )
					.build();

				const _position = new THREE.Vector3();

				// Sample randomly from the surface, creating an instance of the sample
				// geometry at each sample point.
				for ( let i = 0; i < 3; i ++ ) {

					sampler.sample( _position );
					genTrace(_position, i);

				}

			}

			function getRandomInt(min, max) {
			    min = Math.ceil(min);
			    max = Math.floor(max);
			    return Math.floor(Math.random() * (max - min + 1)) + min;
			}

			// Trace constructor + Gen Trace data po

			function genTrace(data) {

				var position = new THREE.Vector3(data.x, data.y, data.z);



				orientation.copy( mouseHelper.rotation );

				//if ( params.rotate ) orientation.z = Math.random() * 2 * Math.PI;

				// Size of trace : 
				const scale = params.minScale + Math.random() * ( params.maxScale - params.minScale );
				size.set( scale, scale, scale );

				const material =  new THREE.MeshPhongMaterial( {
						//color: color,
						map: textureLoader.load( 'texture/cv/'+data.map ),
						bumpMap :    textureLoader.load( 'texture/cv/'+data.bumpmap ),
						bumpScale : 30,
						opacity: 0.6,
						depthWrite: false,
    					alphaTest: 0.05,
						shininess: 25,
						transparent: true,
						depthTest: true,
						side: THREE.DoubleSide, 
						polygonOffset: true,
						polygonOffsetFactor: - 4,
						wireframe: false
					} );
			
				const m = new THREE.Mesh( new THREE.DecalGeometry( mesh, position, orientation, size ), material );

				m.userData.freq = data.freq;

				var nSound = getRandomInt(1,3);
				var sound = new THREE.PositionalAudio( listener );
				var audioElem;// = document.getElementById( data.sound );



				var checkExist = setInterval(function() {
					
				   if (audioElem = document.getElementById( data.sound )) {

				      clearInterval(checkExist);
				      sound.setMediaElementSource( audioElem );
					  sound.setRefDistance( 20 );
					  sound.setVolume( 10 );
					  audioElem.play();
					  m.add( sound );


				   }
				}, 100); 



				m.layers.enable( BLOOM_SCENE );
				// if date != today

				/*
				if(data.day == today){

					// Bloom on the trace proportional to time left :

					var curr_time = new Date().toLocaleTimeString();
					var time_left =Math.ceil(  (hmsToSeconds(curr_time) - hmsToSeconds(data.hour))/60);

					m.layers.enable( BLOOM_SCENE );
					const color = new THREE.Color();
					var luminance = ramp(time_left, 0, 1440 , 1, 0); // map minutes left to luminance value

					color.setHSL( 0, 0 , luminance );
					m.material.color = color;
					m.material.needsUpdate = true
				}

				*/

				decals.push( m );
				scene.add( m );


			}

			function removeDecals() {

				decals.forEach( function ( d ) {

					scene.remove( d );

				} );

				decals.length = 0;

			}

			function animate() {

				requestAnimationFrame( animate );

				//renderer.render( scene, camera );
				render();

				stats.update();

			}

			function render(){
				// render scene with bloom
				renderBloom( true );

				// render the entire scene, then render bloom scene on top
				finalComposer.render();

			}

			function renderBloom( mask ) {

				if ( mask === true ) {

					scene.traverse( darkenNonBloomed );
					bloomComposer.render();
					scene.traverse( restoreMaterial );

				} else {

					camera.layers.set( BLOOM_SCENE );
					bloomComposer.render();
					camera.layers.set( ENTIRE_SCENE );

				}

			}

			function darkenNonBloomed( obj ) {


				if ( obj.isMesh && bloomLayer.test( obj.layers ) === false ) {

					materials[ obj.uuid ] = obj.material;
					obj.material = darkMaterial;

				}
				else if(obj.isMesh && bloomLayer.test( obj.layers ) === true ){

					var nu = obj.userData.freq; //0.5; //Hz
					var c = new THREE.Color();
					obj.material.color.getHSL(c);

				/*	if (c.l<=0.2) dir=-1;
					if (c.l>=0.8) dir=1; */


					time = clock.getElapsedTime();
					var tau = 10; 
					var intensity = 0.8;
					//obj.material.color.setHSL( 0, 0 , 0.8 + 0.2*(Math.sin(6.28 * nu * time)));  // amplitude
					obj.material.color.setHSL( 0, 0 , 0.1 + Math.exp(-time / tau) * (intensity + 0.2*(Math.sin(6.28 * nu * time))));  // amplitude

					//obj.material.color.setHSL( 0, 0 , 0.5 + 0.2*(Math.sin(6.28 * nu * time)));


					 // nu varie de 0 à 0.5. freq d'osc par trace

					// Math.exp(-time / tau); // Varie entre 1 a t=0 et 0 a t=infiny

					/*
					var luminance = ramp(time_left, 0, 1440 , 1, 0); 
					console.log(luminance);
					color.setHSL( 0, 0 , luminance );
					m.material.color = color;
					m.material.needsUpdate = true */
				}

			}

			function restoreMaterial( obj ) {

				if ( materials[ obj.uuid ] ) {

					obj.material = materials[ obj.uuid ];
					delete materials[ obj.uuid ];

				}

			}

			window.onresize = function () {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

				bloomComposer.setSize( width, height );
				finalComposer.setSize( width, height );

				render();

			};



		</script>

	</body>
</html>
